\documentclass{article}
\usepackage{cite}
\usepackage{url}

\begin{document}
\section{Columnar stores}
\subsection{Cassandra}

Apache Cassandra, originally developped at Facebook but later open-sourced, combines the data-model of Google's BigTable system with the architecture and distribution strategy of Amazon's DynamoDB. It is intended for flexible, highly-available storage of very large datasets, running on cheap commodity hardware and offering high write throughput while not sacrificing read efficiency \cite{lakshman2010cassandra}.
\\
Since its inception Cassandra has however diverged slightly from the BigTable data model. It now offers tables and composite columns -much like in a conventional schema, and comes with its own query language, CQL\cite{cassandra_then&now}. CQL resembles SQL in many ways, but comes with some restrictions. For instance, it doesn't feature the JOIN clause \cite{cassandra_cql}. It strongly encourages physically collocating data that will be queried together, and supports denormalization with features such as collection types.\\
In order to scale linearly in the number of nodes to very large datasets, Cassandra operates in a fully masterless fashion. In terms of the CAP-theorem, it focusses on availability and partition-tolerance, rather than immediate consistency (though the user has control over the level of consistency, as will be explained). High availability and partition tolerance are achieved through asynchronous replication of rows over several nodes in the cluster, using consistent hashing and virtual nodes to handle high churn and incremental addition of nodes \cite{decandia2007dynamo} \cite{lakshman2010cassandra} \cite{cassandra_then&now}. The amount of replicas can be chosen by the client. Furthermore, Cassandra provides cross-datacenter replication to cope with entire datacenter failures.
\\On reads and writes, the client can specify the desired quorum, that is the number of replicas that acknowledge the operation. Although Cassandra was built with eventual consistency in mind, strong consistency can be obtained by choosing the quorum larger than the number of replicas \cite{grolinger2013data}.\\
In terms of concurrency control, Cassandra offers atomicity for single-row operations and serializable \textit{lightweight transactions}, essentially a compare-and-set functionality for larger operations \cite{cassandra_lightweight_trans}.\\
Being an open-source project, Cassandra is freely available, but there is an enterprise version with extra features such as integration with Apache Spark and Apache Solr, for complex analytical and search tasks \cite{cassandra_solr} \cite{cassandra_spark}.\\\\
In conclusion, Cassandra offers flexible data-modeling with decent querying and indexing support through its CQL-interface and scales incrementally to vast datasets, thanks to its extensive replication and failure-handling features.

\subsection{HBase}

Apache HBase is an open source datastore using Google BigTable's datamodel, but running on top of the Hadoop Distributed File System (HDFS) instead of the Google File System (GFS).
\\Since its launch, HBase has adopted several secondary indexing mechanisms. HBase doesn't offer an SQL-like advanced querying language, but because of its HDFS underpinnings it can function as both input and output for Map/Reduce jobs.
\\The strong points of HBase are its strong consistency, which is rare among NoSQL-stores, and its concurrency model: ACID-compliant single row transactions and optimistic multi-version concurrency control for wider scope operations\cite{hbase_acid}\cite{grolinger2013data}\cite{borthakur2011apache}.\\\\
In conclusion, HBase offers flexible data-modeling and is especially useful when there is already a HDFS dataset and when Map/Reduce compatibility is desired. It scales well to very large datasets and offers excellent concurrency control and strong consistency.

\section{NewSQL}
\subsection{VoltDB}

VoltDB is a relational in-memory distributed database, aiming to offer the guarantees of classical SQL-stores and the performance and scaling of NoSQL systems\cite{stonebraker2013voltdb}. %TODO rewrite
\\VoltDB stores data in the traditional relational model, but replicated and partitioned (using consistent hashing) over several nodes\cite{grolinger2013data}. The data is queryable through a (growing) subset of SQL-92 \cite{voltdb2010voltdb}.
Relying entirely on DRAM makes it expensive to scale to petabyte scale datavolumes, but VoltDB can export data to other, more suited DMBSs such as columnar NoSQL stores.
\\In terms of concurrency control, VoltDB offers full ACID-transactions which execute simultaneously on all replicas. Main memory is divided into chunks and these are statically assigned to individual, single-threaded cores. A global controller serializes all multi-node transactions single-node transactions and are inserted into the transactions queues of the respective nodes. In this way, VoltDB obviates the need for locking and latching techniques.
\\\\
In short, VoltDB provides relational in memory storage for relatively large datasets, with very fast SQL-query capacities and ACID transactions. It is thus more suited for computation intensive applications that don't work on exorbitantly large data volumes but require very low latency.

\bibliography{biblio}{}
\bibliographystyle{plain}
\end{document}